'use strict'

const { __logger } = require('./debugger-tools')

const defaultCommonFields = {
  year: "Int",
  month: "Int",
  statusId: "String",
  realmId: "String",
  kingdomId: "String",
  agencyId: "String",
  teamId: "String",
  userId: "String",
  countryId: "String",
  stateId: "String",
  cityId: "String",
  companyId: "String",
  mgaId: "String",
  leadId: "String",
  _id: "String"
}

const queryExtend = (query, extraQuery) => {

  extraQuery = JSON.parse(JSON.stringify(extraQuery))
  query = { ...query, ...extraQuery }

  return query
}

/**
 * find: object
 * lookups: [{ from, localField, foreignField, as, type, unwind }]
 * options: Object
 *
 * * La estrcutura del array de lookups es:
 * from: required: coleccion donde buscara la data
 * localField: optional: campo de la coleccion local para relaciones. Si no se pasa, tomara el from y le contactena un
 * ID: ejemplo: {from: 'lead'}, default localField = leadId foreignField: optional: campo de la coleccion foranea a
 * relacionesl. Default: "_id" as: optional: nombre de propiedad con el que se guarda. Default es from type: optional:
 * Por default siempre se hara unwind. Para evitarlo se pasa type: "array". Default: undefined unwind: optional:
 *
 * LIMITADO PARA EXPRESS JS o CUALQUIER FRAMEWORK NODE QUE USE Mongoose 5.*+
 */
const generateLookups = (find, lookups = [], { debug = false } = {}) => {

  lookups.map(lookup => {
    const _lookup = {
      from: lookup.from,
      localField: lookup.localField || `${lookup.from}Id`,
      foreignField: lookup.foreignField || '_id',
      as: lookup.as || lookup.from
    }

    if (lookup.let) {
      delete _lookup.localField
      delete _lookup.foreignField

      _lookup.let = lookup.let
      _lookup.pipeline = lookup.pipeline
    }

    if (debug) {
      __logger(`lookup: ${JSON.stringify(_lookup)}`, '')
    }

    find.lookup(_lookup)

    if (lookup.type !== 'array') {
      const unwind = typeof lookup.unwind === 'object' ?
                     lookup.unwind :
        {
          path: lookup.unwind || `$${lookup.as || lookup.from}`,
          // preserveNullAndEmptyArrays: lookup.preserveNullAndEmptyArrays === undefined ? true :
          // lookup.preserveNullAndEmptyArrays
          preserveNullAndEmptyArrays: lookup.preserveNullAndEmptyArrays || false,
          // includeArrayIndex: lookup.includeArrayIndex
        }
      if (debug) {
        __logger(`unwind: ${JSON.stringify(unwind)}`, '')
      }
      find.unwind(unwind)
    }
  })

  return find
}

/**
 * Devuelve un objeto sin propiedades que tengan valores undefined
 * @param obj
 * @returns {any}
 */
const cleanJSONObject = obj => {
  return JSON.parse(JSON.stringify(obj))
}

/**
 *
 * @param filter
 * @param additionalFields
 * @param debug
 * @param noDefaultFields
 * @returns {*}
 */
const makeQuery = (filter = {}, additionalFields = {}, { debug = process.env.DEBUG } = {}) => {

  if (debug) console.log('%c filter', 'color:white;background-color:red', filter);

  const availableFields = [
    ...Object.keys(defaultCommonFields),
    ...Object.keys(additionalFields)
  ]

  if (debug) console.log('%c availableFields', 'color:white;background-color:red', availableFields);

  /**
   * usar para iniciar valores por default
   */
  const filterProps = {
    // years: [moment().year()]
  }

  const queryProps = {}

  availableFields.map(field => {
    filterProps[`${field}s`] = !filter[`${field}s`] && filterProps[`${field}s`] ?
                               filterProps[`${field}s`] :
                               filter[`${field}s`]
    queryProps[field] = undefined

    if (filterProps[`${field}s`] && filterProps[`${field}s`].length > 0) {
      queryProps[field] = { $in: filterProps[`${field}s`] }
    } else if (filter[field]) {
      queryProps[field] = filter[field]
    }


  })

  const query = cleanJSONObject(queryProps)

  if (debug) console.log('%c query', 'color:white;background-color:red', query);

  return query
}

/**
 * Se utiliza para generar un string que sera usado en type gql (_inherits)
 * @returns {string}
 */
const defaultCommonFieldsFormatted = (fields = defaultCommonFields) => {
  let string = ''
  /**
   * Aca genero primero los campos en plural tipo array
   */
  Object.keys(fields).map(field => {
    string += `${field}s: [${fields[field]}]\n`
  })
  /**
   * Aca genero los singulares
   */
  Object.keys(fields).map(field => {
    string += `${field}: ${fields[field]}\n`
  })
  return string
}

/**
 *
 * @param filter
 * @param additionalFields
 * @param debug
 * @param noDefaultFields
 * @returns {*}
 */
const generateQuery = (filter = {}, additionalFields = {}, { debug = process.env.DEBUG, noDefaultFields = false } = {}) => {

  if (debug) console.log('%c filter', 'color:white;background-color:red', filter);

  let availableFields = []

  if(!noDefaultFields) {
    availableFields = [...availableFields, ...Object.keys(defaultCommonFields)]
  }

  availableFields = [...availableFields, ...Object.keys(additionalFields)]

  if (debug) console.log('%c availableFields', 'color:white;background-color:red', availableFields);

  /**
   * usar para iniciar valores por default
   */
  const filterProps = {
    // years: [moment().year()]
  }

  const queryProps = {}

  availableFields.map(field => {
    if(filter[field]) {
      switch (true) {

        case field.endsWith('_contains'):
          queryProps[field.replace('_contains', '')] = {
            $regex: filter[field], $options: 'ig'
          }
          break

        case field.endsWith('_starts_with'):
          queryProps[field.replace('_starts_with', '')] = {
            $regex: `^${filter[field]}`, $options: 'igm'
          }
          break

        case field.endsWith('_ends_with'):
          queryProps[field.replace('_ends_with', '')] = {
            $regex: `${filter[field]}$`, $options: 'igm'
          }
          break

        case field.endsWith('_not_in'):
          queryProps[field.replace('_not_in', '')] = {
            $nin: filter[field]
          }
          break

        case field.endsWith('_in'):
          queryProps[field.replace('_in', '')] = {
            $in: filter[field]
          }
          break

        case field.endsWith('_not_equal'):
          queryProps[field.replace('_not_equal', '')] = {
            $ne: filter[field]
          }
          break

        default:
          queryProps[field] = filter[field]
          break
      }
    }
  })

  const query = cleanJSONObject(queryProps)

  if (debug) console.log('%c query', 'color:white;background-color:red', query);

  return query
}

const generateFilterFieldsSchemaString = (fields = defaultCommonFields) => {
  let string = ''
  /**
   * Aca genero primero los campos en plural tipo array
   */
  Object.keys(fields).map(field => {
    switch (true) {

      case field.endsWith('_in'):
        string += `${field}: [${fields[field]}]\n`
        break

      default:
        string += `${field}: ${fields[field]}\n`
        break
    }
  })

  return string
}

const generateFilterFields = fields => {

  Object.keys(fields).map(field => {
    fields[`${field}_not_equal`] = fields[field]
    fields[`${field}_in`] = [fields[field]]
    fields[`${field}_not_in`] = [fields[field]]
    fields[`${field}_contains`] = fields[field]
    fields[`${field}_starts_with`] = fields[field]
    fields[`${field}_ends_with`] = fields[field]
  })

  return fields
}

/**
 * version unificada de los metodos de generateFilterFields y generateFilterFieldsSchemaString
 * @param fields
 * @returns {string}
 */
const generateFilterFieldsSchema = fields => {
  fields = generateFilterFields(fields)

  return generateFilterFieldsSchemaString(fields)
}

module.exports = {
  queryExtend,
  generateLookups,
  cleanJSONObject,
  makeQuery, // genera el query en base a los filtros
  _defaultCommonFields: defaultCommonFieldsFormatted(),
  _generateTypeString: defaultCommonFieldsFormatted, // genera un string para los types en base a los filtros
  // nuevas versiones
  generateQuery, // genera el query en base a los filtros (makeQuery_v2)
  generateFilterFields, // genera el objeto de filtros con todas las props nuevas
  generateFilterFieldsSchemaString, // genera el string para el schema de gql en base a los filters
  // version unificada de los metodos de generateFilterFields y generateFilterFieldsSchemaString
  generateFilterFieldsSchema
};
