'use strict'

const randomString = require("randomstring")
const { timingSafeEqual } = require('crypto')
const formatCurrency = require('format-currency')
const moment = require('moment')
const { daysInWeek } = require('./dataSet')

const convertConstantToArray = (obj) => {
  var list = []
  var keys = Object.keys(obj)
  for (var i = 0; i < keys.length; i++) {
    var item = obj[keys[i]]
    item.alter = keys[i]
    list.push(item)
  }

  return list
}

const convertSpecificToObject = function (obj, id) {
  var keys = Object.keys(obj)

  for (var i = 0; i < keys.length; i++) {
    if (obj[keys[i]]._id === id) return obj[keys[i]]
  }
}

const convertObjectToArray = function (obj) {
  return Object.keys(obj).map(function (k) { return obj[k] })
}

const listObjectToSimple = function (list, key) {
  var result = []

  for (var i = 0; i < list.length; i++) {
    result.push(list[key])
  }

  return result
}

const strReplaceAll = function (str, replace, by) {
  return str.replace(new RegExp(replace, 'g'), by)
}

const isBase64 = function (text) {
  return text && typeof text === 'string' && text.includes('data:') && text.includes(';base64')
}

const setAsObject = function (data) {
  if (data && typeof data !== 'object') {
    data = JSON.parse(data)
  }
  return data
}

const orderJson = function (obj) {
  var array = []
  for (const a in obj) {
    array.push([a,
                obj[a]])
  }
  array.sort(function (a, b) {return a[1] - b[1]})
  array.reverse()
}

const _randomString = function (length) {
  length = !length ?
           8 :
           length
  var text = ''
  var possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvxyz0123456789'
  for (var i = 0; i < length; i++) {
    text += possible.charAt(Math.floor(Math.random() * possible.length))
  }
  return text
}

const capitalizeFirstLetter = function (string) {
  return string && string !== '' ?
         string.charAt(0).toUpperCase() + string.slice(1) :
         undefined
}

const generateId = length => {
  length = length || 17
  return randomString.generate(length)
}

const handlePagination = (params = {}, type, options = {}) => {

  let pagination = {}

  const { defaultLimit = 20 } = options

  switch (type) {

    case 'neo':
    case 'neo4j':
      const { first = defaultLimit, offset = 0 } = params
      pagination = {
        first,
        offset
      }
      break

    default:
      const { page, limit } = params
      let paging = page ?
                   page - 1 :
                   0

      pagination = {
        skip: paging * limit,
        limit
      }
      break
  }

  return pagination

}

const unique = array => Array.from(array.filter((value, index, self) => self.indexOf(value) === index))

const safeCompare = (a, b) => {
  const aLength = Buffer.byteLength(a)
  const bLength = Buffer.byteLength(b)

  const aBuffer = Buffer.alloc(aLength, 0, 'utf8')
  aBuffer.write(a)
  const bBuffer = Buffer.alloc(aLength, 0, 'utf8')
  bBuffer.write(b)

  return !!(timingSafeEqual(aBuffer, bBuffer) & aLength === bLength)
}

const currency = (value, config = {}) => {

  const {
    fixed = 2
  } = config

  return parseFloat((value).toFixed(fixed))
}

/**
 * Parameters:
 value: Value to convert. Will pass through parse-num first. Will coerce anything to a number.
 options: optional object parameter to specify options. Appending Digits is not necessary. You can also shorten maximum to max and minimum to min. Adds one more option nanZero, which when the number is NaN, if it should be coerced to 0 - defaults to true i.e. NaN => '0'. Also available code, symbol, format.
 * @param value
 * @param options
 */
const parseCurrency = (value, options = {}) => {

  const {
    symbol = '$',
    locale = 'en-US',
    code = 'USD',
    format = '%s %v',
    maxFraction = 2
  } = options

  const newVal = formatCurrency(value, {
    symbol,
    locale,
    code,
    format,
    maxFraction
  })
  if (options.debug) {
    console.log(`formatCurrency: ${newVal}`)
  }
  return newVal
}

/**
 *
 * @param {(string|number)} rawNumber - Phone Number
 * @param {string} [usage=upsert|numSearch|search] - Usage
 * @returns {string}
 */
const parsePhoneNumber = (rawNumber, usage) => {
  /**
   * --2017805567 country-less
   *  12017805567 US
   * 525512345678 MX
   * 573022408394 CO
   * 584140598652 VE
   *
   * +  1 201 780 5567
   * + 52 551 234 5678
   * + 57 302 240 8394
   * + 58 414 059 8652
   *
   * +12017805567
   * +525512345678
   * +573022408394
   * +584140598652
   */

  let defaultResponse = !!rawNumber ?
                        rawNumber :
                        ''

  let isUpsert = ''
  if (usage === 'upsert' || usage === null || typeof usage === 'undefined') {
    defaultResponse = undefined
    isUpsert = '+'
  } else if (usage === 'numSearch') {
    defaultResponse = defaultResponse.replace((new RegExp('(\\D)', 'g')), '')
  }

  if (!rawNumber || typeof rawNumber === 'object') {
    return defaultResponse
  }

  const regex = new RegExp('(\\D)', 'g')
  let parsedNumber = rawNumber.replace(regex, '').toString()
  const parsedNumberLength = parsedNumber.length

  if (!parsedNumberLength) {
    return defaultResponse
  }

  if (parsedNumberLength < 10 || parsedNumberLength > 12) {
    return defaultResponse
  } else if (parsedNumberLength === 10) {
    /**
     * normal length of phone number without country code
     * default country code is US aka 1
     */
    parsedNumber = 1 + parsedNumber
  } else if (parsedNumberLength === 11) {
    if (parsedNumber[0] !== '1') {
      /**
       * if first digit is not 1, it's invalid
       */
      return defaultResponse
    }
  } else if (parsedNumberLength === 12) {
    /**
     * only country codes to be considered valid besides US, are MX 52, CO 57 and VE 58
     * everything else is invalid
     */
    if (!(parsedNumber[0] === '5' && (parsedNumber[1] === '2' || parsedNumber[1] === '7' || parsedNumber[1] === '8'))) {
      return defaultResponse
    }
  }

  return isUpsert + parsedNumber
}

const normalize = (str) => {
  var from = "ÃÀÁÄÂÈÉËÊÌÍÏÎÒÓÖÔÙÚÜÛãàáäâèéëêìíïîòóöôùúüûÑñÇç",
    to = "AAAAAEEEEIIIIOOOOUUUUaaaaaeeeeiiiioooouuuunncc",
    mapping = {}

  for (let i = 0, j = from.length; i < j; i++)
    mapping[from.charAt(i)] = to.charAt(i)

  var ret = []
  for (let i = 0, j = str.length; i < j; i++) {
    var c = str.charAt(i)
    if (mapping.hasOwnProperty(str.charAt(i)))
      ret.push(mapping[c])
    else
      ret.push(c)
  }
  return ret.join('')

}

/**
 * retorna un string abreviado por iniciales
 * @param string
 * @param regex
 * @returns {*}
 */
const abbr = (string, regex = /-|_|\s/) => {
  let abbr = ''
  const rest = string.split(regex)
  rest.map(r => {
    abbr += `${r[0]}.`
  })
  return abbr
}

/**
 *
 * @param dob fecha de nacimiento
 * @param origin en caso de calcular en base a otra fecha de orgine default fecha actual
 * @returns {*}
 */
const calculateAge = (dob, origin) => {
  const to = !origin ?
             moment() :
             moment(new Date(origin))
  const birthDate = moment(new Date(dob))
  const age = to.diff(birthDate, 'years'); // calculates patient's age in years
  return age
}

const randomLimit = function (min = 0, max) {
  return Math.floor(Math.random() * (max - min + 1) + min)
}

const generateRandomFileName = (filename) => {
  const ext = filename.split('.')
  return Date.now() + randomLimit(0, 9999) + _randomString(15) + '.' + (ext)[ext.length - 1].toLowerCase()
}

const removeAccents = (strAccents) => {
  strAccents = strAccents.split('')
  let strAccentsOut = []
  let strAccentsLen = strAccents.length
  let accents = "ÀÁÂÃÄÅàáâãäåÒÓÔÕÕÖØòóôõöøÈÉÊËèéêëðÇçÐÌÍÎÏìíîïÙÚÛÜùúûüÑñŠšŸÿýŽž"
  let accentsOut = "AAAAAAaaaaaaOOOOOOOooooooEEEEeeeeeCcDIIIIiiiiUUUUuuuuNnSsYyyZz"
  for (let y = 0; y < strAccentsLen; y++) {
    if (accents.indexOf(strAccents[y]) !== -1) {
      strAccentsOut[y] = accentsOut.substr(accents.indexOf(strAccents[y]), 1)
    } else {
      strAccentsOut[y] = strAccents[y]
    }
  }
  strAccentsOut = strAccentsOut.join('')

  return strAccentsOut
}

const nameSanitizer = name => {
  name = removeAccents(name)
  name = name.replace(/[^a-z0-9-_.\s]/gi, '').replace(/[-\s]/g, '_')
  return name.trim()
}

const stringToCamelCase = (string, pattern = '-') => {
  let newString = ''
  const words = string.split(pattern)
  words.map((word, index) => {
    if (index > 0) {
      word = word[0].toUpperCase() + word.substr(1, word.length - 1)
    } else if (index === 0) {
      word = word[0].toLowerCase() + word.substr(1, word.length - 1)
    }
    newString += word
  })

  return newString
}

const isValidJSONString = (string) => {
  try {
    const o = JSON.parse(string)
    if (o && typeof o === "object") {
      return true
    }
  } catch (e) {
  }
  return false
}

const checkByPass = (str = '') => {
  const secret = process.env.BY_PASS_SECRET || 'letMEexec'
  if (!safeCompare(str, secret) && process.env.BY_PASS === 'true') {
    throw new Error('forbidden')
  }
}

const getYearsInBetweenTwoDates = (init, end) => {
  let initDate = new Date(init)
  let endDate = new Date(end)

  if (initDate > endDate) {
    const tempInit = initDate
    initDate = endDate
    endDate = tempInit
  }

  const initYear = new Date(initDate).getFullYear()
  const endYear = new Date(endDate).getFullYear()
  const years = []

  for (let i = 0; i < (endYear - initYear); i++) {
    years.push(initYear + i)
  }
  if (years.indexOf(endYear) === -1) {
    years.push(endYear)
  }
  return years
}

/**
 * DEPRECATED
 * Este metodo sirve para organizar los filtros que se envian por un resolver.
 * Dependen de un type dentro de la definicion del resolver.
 * Por ahora es un alfa-beta.
 */
const handleFilters = (filters = {}, debug) => {
  console.log('%c handleFilters deprecated. Gonna to be removed in future versions', 'color:white;background-color:red')
  const query = {}
  Object.keys(filters).map(filter => {
    query[filter] = { $eq: filters[filter] }
  })
  if (debug) {
    console.log('%c query', 'color:white;background-color:red', query)
  }
  return query
}

Math.radians = degrees => {
  return degrees * Math.PI / 180
}

/**
 *
 * @param x{.lat, .lng}
 * @param y{.lat, .lng}
 * @param unit = "km"|"mi"
 * @returns {null|number}
 */
const calculateDistanceBetweenCoords = (x, y, unit = 'km') => {
  const milesConst = 3963.17
  const kmsConst = 6378.10
  let unitValue
  switch (unit) {
    case "km":
      unitValue = kmsConst
      break
    case 'mi':
      unitValue = milesConst
      break
    default:
      return null
  }
  return (
    unitValue * (
      Math.acos(
        Math.cos(Math.radians(x.lat)) *
        Math.cos(Math.radians(y.lat)) *
        Math.cos(Math.radians(y.lng) - Math.radians(x.lng)) +
        Math.sin(Math.radians(x.lat)) *
        Math.sin(Math.radians(y.lat))
      ) || 0)
  )
}

const ascOrder = (a, b) => a - b

const descOrder = (a, b) => b - a

/**
 *
 * @param numerator: 1
 * @param denominator: 2
 * @returns {number}: 0.5
 */
const fractionIndex = (numerator, denominator) => {
  numerator = !numerator ?
              0 :
              numerator
  denominator = !denominator ?
                1 :
                denominator
  return numerator / denominator
}

/**
 *
 * @param index: 0.5
 * @param decimalPlaces: 2
 * @returns {string}: 50.00%
 */
const indexToPercentage = (index, decimalPlaces = 2) => {
  const tenToN = 10 ** decimalPlaces
  return (Math.round((index * 100 + Number.EPSILON) * tenToN) / tenToN).toFixed(decimalPlaces) + '%'
}

/**
 *
 * @param numerator: 1
 * @param denominator: 2
 * @param decimalPlaces: 2
 * @returns {string}: 50.00%
 */
const fractionToPercentage = (numerator, denominator, decimalPlaces = 2) => {
  return indexToPercentage(fractionIndex(numerator, denominator), decimalPlaces)
}

const humanFileSize = (bytes, si = true) => {
  let thresh = si ?
               1000 :
               1024
  if (Math.abs(bytes) < thresh) {
    return bytes + ' B'
  }
  let units = si
              ?
    ['kB',
     'MB',
     'GB',
     'TB',
     'PB',
     'EB',
     'ZB',
     'YB']
              :
    ['KiB',
     'MiB',
     'GiB',
     'TiB',
     'PiB',
     'EiB',
     'ZiB',
     'YiB']
  let u = -1
  do {
    bytes /= thresh
    ++u
  } while (Math.abs(bytes) >= thresh && u < units.length - 1)
  return bytes.toFixed(1) + ' ' + units[u]
}

/**
 * Ordena de forma random un array
 * @param array
 * @returns {*}
 */
const shuffle = array => {
  let currentIndex = array.length, temporaryValue, randomIndex

  // While there remain elements to shuffle...
  while (0 !== currentIndex) {

    // Pick a remaining element...
    randomIndex = Math.floor(Math.random() * currentIndex)
    currentIndex -= 1

    // And swap it with the current element.
    temporaryValue = array[currentIndex]
    array[currentIndex] = array[randomIndex]
    array[randomIndex] = temporaryValue
  }

  return array
}

/**
 *
 * @param originalString
 * @param action
 */
const transformString = (originalString, action) => {
  switch (action.toLowerCase()) {
    case 'capitalize':
    case 'c':
      var string = '';
      originalString.split(' ').map(word => {
        string += word.charAt(0).toUpperCase() + word.toLowerCase().slice(1) + ' ';
      });
      originalString = string.substr(0, string.length - 1);
      break;

    case 'upper':
    case 'u':
      originalString = originalString.toUpperCase();
      break;

    default:
      originalString = originalString.toLowerCase();
      break;
  }

  return originalString.trim()
}

String.prototype.transform = function(action) {
  return transformString(this, action)
}

/**
 * Remove null, undefined, zero and empty string for an array
 * @param arr
 * @returns {*}
 */
const cleanArray = arr => {
  return arr.reduce((acc, el) => {
    if(el) acc.push(el)
    return acc
  }, [])
}

/**
 * no enviar un moment object;
 * solo date time o string
 * @param date
 */
const getDateDetails = (date) => {
  date = date ? new Date(date) : new Date()
  const dayOfWeek = moment(date).day()
  return {
    datetime: date,
    ms: moment(date).valueOf(),
    month: moment(date).month()+1,
    year: moment(date).year(),
    dayOfMonth: moment(date).date(),
    dayOfWeek,
    dayOfWeekHumanize: daysInWeek[dayOfWeek].toLowerCase(),
    week: moment(date).week(),
    quarter: moment(date).quarter(),
    dayOfYear: moment(date).dayOfYear()
  }
}

const deepDiffMapper = function () {
  return {
    VALUE_CREATED: 'created',
    VALUE_UPDATED: 'updated',
    VALUE_DELETED: 'deleted',
    VALUE_UNCHANGED: 'unchanged',
    map: function(oldObj, newObj) {
      if (this.isFunction(oldObj) || this.isFunction(newObj)) {
        throw 'Invalid argument. Function given, object expected.';
      }
      if (this.isValue(oldObj) || this.isValue(newObj)) {

        return {
          type: this.compareValues(oldObj, newObj),
          old: oldObj || null,
          new: newObj || null
        };
      }

      let diff = {};
      for (let key in oldObj) {
        if (this.isFunction(oldObj[key])) {
          continue;
        }

        let value2 = undefined;
        if (newObj[key] !== undefined) {
          value2 = newObj[key];
        }

        diff[key] = this.map(oldObj[key], value2);
      }
      for (let key2 in newObj) {
        if (this.isFunction(newObj[key2]) || diff[key2] !== undefined) {
          continue;
        }

        diff[key2] = this.map(undefined, newObj[key2]);
      }

      return diff;
    },
    compareValues: function (value1, value2) {
      if (value1 === value2) {
        return this.VALUE_UNCHANGED;
      }
      if (this.isDate(value1) && this.isDate(value2) && value1.getTime() === value2.getTime()) {
        return this.VALUE_UNCHANGED;
      }
      if (value1 === undefined) {
        return this.VALUE_CREATED;
      }
      if (value2 === undefined) {
        return this.VALUE_DELETED;
      }
      return this.VALUE_UPDATED;
    },
    isFunction: function (x) {
      return Object.prototype.toString.call(x) === '[object Function]';
    },
    isArray: function (x) {
      return Object.prototype.toString.call(x) === '[object Array]';
    },
    isDate: function (x) {
      return Object.prototype.toString.call(x) === '[object Date]';
    },
    isObject: function (x) {
      return Object.prototype.toString.call(x) === '[object Object]';
    },
    isValue: function (x) {
      return !this.isObject(x) && !this.isArray(x);
    }
  };
}()

const getDiffObjects = function () {
  return {
    init: function (items, excludeType) {
      let diff = {};

      if(items.type) {
        if(items.type !== excludeType) diff = items;
      }
      else {
        Object.entries(items).forEach(([key, item]) => {
          if(item.type) {
            if(item.type !== excludeType) {
              diff[key] = item;
            }
          } else {
            diff[key] = this.init(item, excludeType);
          }

          if(diff[key] && this.isObject(diff[key]) && this.isEmptyObject(diff[key]) || key === 'forms') delete diff[key];
        });
      }
      return diff;
    },
    isObject: (item) => typeof item === 'object',
    isEmptyObject: (obj) => !Object.keys(obj).length
  };
}()

const splitItem = (label, row) => {
  label = label.replace(/\[(\w+)]/g, '.$1') // convert indexes to properties
  label = label.replace(/^\./, '')           // strip a leading dot
  const a = label.split('.')
  for (let i = 0, n = a.length; i < n; ++i) {
    const k = a[i]
    if (k in row) {
      row = row[k]
    } else {
      return
    }
  }
  return row
}

const stringFormat = function (replaces) {

  let theString = this.toString();
  let newArguments;
  let notAnObject = true;
  if (arguments.length > 1) {
    newArguments = arguments;
  } else {
    if (Array.isArray(replaces)) {
      newArguments = replaces;
    }
    else if(typeof replaces === 'object' && replaces instanceof Object) {
      notAnObject = false;
      for(const key in  replaces) {
        const regEx = new RegExp('\\{\\{' + (key) + '\\}\\}', 'gm');
        theString = theString.replace(regEx, replaces[key]);
      }
    }
    else {
      newArguments = [replaces];
    }
  }

  if(notAnObject) {
    for (let i = 0; i < newArguments.length; i++) {
      const regEx = new RegExp('\\{' + (i) + '\\}', 'gm');
      theString = theString.replace(regEx, newArguments[i]);
    }
  }

  return theString;
}

/* Check if string is IP */
function checkIfValidIP(str) {
  const regexExp = /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/gi
  return regexExp.test(str)
}

module.exports = {
  convertConstantToArray,
  convertSpecificToObject,
  convertObjectToArray,
  listObjectToSimple,
  strReplaceAll,
  isBase64,
  setAsObject,
  orderJson,
  randomString: _randomString,
  capitalizeFirstLetter,
  generateId,
  handlePagination,
  unique,
  safeCompare,
  currency,
  parseCurrency,
  parsePhoneNumber,
  normalize,
  abbr,
  calculateAge,
  generateRandomFileName,
  removeAccents,
  nameSanitizer,
  randomLimit,
  stringToCamelCase,
  isValidJSONString,
  checkByPass,
  getYearsInBetweenTwoDates,
  calculateDistanceBetweenCoords,
  ascOrder,
  descOrder,
  fractionIndex,
  indexToPercentage,
  fractionToPercentage,
  humanFileSize,
  handleFilters,
  shuffle,
  transformString,
  cleanArray,
  getDateDetails,
  deepDiffMapper,
  getDiffObjects,
  splitItem,
  stringFormat,
  checkIfValidIP,
}
